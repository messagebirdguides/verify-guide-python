# Two Factor Authentication (2FA)
### ‚è± 15 min build time

## Why build two factor authentication?

Enterprises are increasingly challenged to keep sensitive information from falling into the wrong hands. This means that we can no longer trust old online authentication systems that rely solely on usernames and passwords, especially as security breaches grow in frequency, severity and sophistication.

With the [MessageBird Verify API](https://www.messagebird.com/en/verify), you can implement two factor authentication (2FA) solutions to provide an additional layer of account security by verifying the user's password with a second authentication token and in turn, secure customer data, block fraudulent accounts, and safeguard key transactions in a matter of minutes. The most common use case involves the application of one-time passwords (OTP) generated by hardware tokens or authenticator apps or directly sent to the user's mobile phone via SMS text messaging.

In this MessageBird Developer Guide, we'll introduce the [MessageBird Verify API](https://www.messagebird.com/en/verify) and show you how to build a runnable application in Python. The application is a prototype for a two factor authentication system deployed by our fictitious online banking application called *BirdBank*.

We'll walk you through the following steps:

- Asking for the phone number
- Sending a verification code
- Verifying the code


**Pro-tip:** Follow this tutorial to build the whole application from scratch or, if you want to see it in action right away, you can download, clone or fork the sample application from the [MessageBird Developer Guides GitHub repository](https://github.com/messagebirdguides/verify-guide-python).

## Getting started

We'll use Python, the [Flask framework](http://flask.pocoo.org/), [Jinja2 templates](http://jinja.pocoo.org/docs/2.10/), as well as [MessageBird's REST API for Python](https://www.npmjs.com/package/messagebird) to build our sample application. Since this application uses HTML forms, we will also use the [WTForms](https://wtforms.readthedocs.io/en/stable/) forms rendering library and the [Flask-WTF library](https://flask-wtf.readthedocs.io/en/stable/), which integrates WTForms with Flask.

We will use Python's pip package manager to install the required packages for Flask. [Install pip](https://pip.pypa.io/en/stable/installing/) if you do not already have it.

## Project Setup

###Application Directory
Let's first create a new directory to store our sample application. This file will contain your main application file, your configuration file, and the Jinja2 templates used by the application.

### Dependencies

Once Python and pip are installed, let's go ahead and install Flask, WTForms, and Flask-WTF with the following commands:

````bash
pip install Flask
````

````bash
pip install WTForms
````

````bash
pip install Flask-WTF
````
You will also need to install the MessageBird Python library, which can also be obtained from pip with the following command:

````bash
pip install messagebird
````
#### Create your API Key üîë

To use the MessageBird REST API, we need to provide an access key for the API. MessageBird provides keys in _live_ and _test_ modes. To get this application running, we will need to create and use a live API access key. Read more about the difference between test and live API keys [here] (https://support.messagebird.com/hc/en-us/articles/360000670709-What-is-the-difference-between-a-live-key-and-a-test-key-).

Let's create your live API access key. First, go to the [MessageBird Dashboard](https://dashboard.messagebird.com/en/user/index); if you have already created an API key it will be shown right there. If you do not see any key on the dashboard or if you're unsure whether this key is in _live_ mode, go to the _Developers_ section and open the [API access (REST) tab](https://dashboard.messagebird.com/en/developers/access). Here, you can create new API keys and manage your existing ones.

If you are having any issues creating your API key, please reach out to our Customer Support team at support@messagebird.com.

**Pro-tip:** Hardcoding your credentials is a risky practice that should never be used in production applications. A better method, also recommended by the [Twelve-Factor App Definition](https://12factor.net/), is to use environment variables.

Flask allows you to specify credentials in a configuration file that is separate from the application. In our example, we create a configuration file named `config_file.cfg`. This is saved in the application directory. Specify your API key in this file as follows:

````env
SECRET_KEY='string'
````
Let's replace the string with your live API key.

You can add more settings in the configuration file. For example, to run the application in debug mode, you can add the following line:

````env
DEBUG=True
````

### Main file

You now have your API key, so let's get started with the main file. In the main directory, we create an `app.py` file that will define the routes used by the web application. This file starts off by including the following dependencies:

````python
from flask import Flask, render_template, request, flash, url_for, redirect
import messagebird
from forms import SubmitPhoneNumber, EnterCode
````

The first two lines import the MessageBird library and the relevant Flask modules. The third line imports classes from a file containing form definitions, which we will explain later.

Then, we create an instance of the application and load the API key from the configuration file:

````python
app = Flask(__name__)
app.config.from_pyfile('config_file.cfg')
````

Next, we create an instance of MessageBird's Python client using our API key:

````python
client = messagebird.Client(app.config['SECRET_KEY'])
````

### HTML Pages

Our Jinja2 templates represent the logic of the application's HTML pages separately from the logic of the code. In the application directory, we create a subdirectory named `templates`, in which we will store our templates. The template for the first page, which asks for the user's phone number, is [index.html](templates/index.html).

After the user successfully enters their phone number, they are redirected to a verification page, where they can enter the verification code that they have just received on their phone. Our template for this page is [entercode.html](templates/entercode.html).

In Jinja2 templates, the curly brackets `{}` represent sections of the page where what appears depends on the logic of the Python code. The variables within the curly brackets will be defined in the Python code. As we step through the code, you will see how the variables in the main application file, `app.py`, relate to those in the templates.

## Asking for the phone number

The first step in verifying a user's phone number is asking them to provide their phone number. We do this by having a template for a HTML form in `index.html`:

````html
{% with messages = get_flashed_messages() %}
  {% if messages %}
    <ul class=flashes>
    {% for message in messages %}
      <li>{{ message }}</li>
    {% endfor %}
    </ul>
  {% endif %}
{% endwith %}
<h1>MessageBird Verify Example</h1>
<p>Enter your phone number:</p>
<form action="{{ url_for('submitPhone') }}" method="post">
<dl>
  {{ initial_form.number }}
  {{ initial_form.submit }}
</dl>
</form>
````
The section that begins with `{% with messages` lets us display error messages. We will explain how this works later. The bottom half of the template represents the HTML form that will collect the user's phone number.

Corresponding to the form in the template is a class, `SubmitPhoneNumber`, that defines the types of fields in the form. To define this class, create a file named `forms.py` in the application directory. The classes defined in this file will have the following dependencies:

````python
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, HiddenField
from wtforms.fields.html5 import TelField #telephone number field
````

 In `forms.py`, `SubmitPhoneNumber` is defined as follows: 

````python
class SubmitPhoneNumber(FlaskForm):
    number = TelField('Phone number')
    submit = SubmitField('Send code')
````

The form is simple, having just one input field and one submit button. Providing `TelField` as the type of our input field allows some browsers, especially those on mobile devices, to optimize for a telephone number input, for example by displaying a numberpad-style keyboard.

Now, it's time to add a route to `app.py` to display the page:

````python
@app.route('/', methods=['GET', 'POST'])
def submitPhone():
    initial_form = SubmitPhoneNumber(request.form)
    code_form = EnterCode()

    #when form is posted, try to obtain server response
    if request.method=="POST":
        try:
            verify = client.verify_create(initial_form.number.data)
            #on success we render verify.id on the hidden field on the verification page (/EnterCode)
            return redirect(url_for('enterCode', code_form=code_form, verify_id=verify.id))
        
        #on failure, log error to console and render error description for error on same page.
        except messagebird.client.ErrorException as e:
            for error in e.errors:
                flash('  description : %s\n' % error.description)
            return render_template('index.html', initial_form=initial_form)

    return render_template('index.html', initial_form=initial_form)
````

This route starts by instantiating the classes of both forms in the application. The verification form class, `EnterCode`, must also be instantiated because it is an argument of the route for the next page. This route will be taken if the phone number submission is successful.

Next, the route creates a new [HLR lookup](https://developers.messagebird.com/docs/lookup) object using the `verify_create` method. If successful, the user is directed to the page where they can enter the verification code they will receive on their phone.

If we fail to create the HLR lookup object, the application will display the error messages in the region defined in the template.

## Sending the verification code

Once we've collected the number, we can send a verification message to the user's mobile device. MessageBird's Verify API takes care of generating a random token, so you don't have to do this yourself. Codes are numeric and six digits by default. If you want to customize the length of the code or configure other options, you can refer to the [Verify API documentation](https://developers.messagebird.com/docs/verify#verify-request).

The form for collecting the verification code is defined by the following template in `entercode.html`:

````html
{% with messages = get_flashed_messages() %}
  {% if messages %}
    <ul class=flashes>
    {% for message in messages %}
      <li>{{ message }}</li>
    {% endfor %}
    </ul>
  {% endif %}
{% endwith %}
    
<div>
  <h1>Enter your verification code</h1>
  <form action="{{ url_for('enterCode', code_form=code_form, verify_id=code_form.verify_id.data) }}" method="post">
    <dl>
    {{ code_form.verify_id }}
    {{ code_form.token }}
    {{ code_form.submit }}
    </dl>
  </form>
</div>
````

As with `index.html`, the top part of the template displays any error messages that occur when the form is submitted. The bottom half contains the form's fields. The user will enter the verification code in the `token` field. The `verify_id` field contains the ID that was returned by the server when the user submitted their phone number. This ID is passed as an argument into the route for `entercode.html`.

As with the previous form, the form fields are defined as a class, `EnterCode`, in `forms.py`:

````python
class EnterCode(FlaskForm):
    verify_id = HiddenField('ID')
    token = StringField('Enter your verification code:')
    submit = SubmitField('Check code')
````

The form in `index.html` submits the phone number via a HTTP POST to the `/enterCode` route, so let's define `app.py`:

````python
@app.route('/EnterCode/<verify_id>', methods=['GET', 'POST'])
def enterCode(verify_id):
    code_form = EnterCode(request.form)

    #prefill verify ID in hidden field
    code_form.verify_id.data = verify_id
    
    #when form is posted, try to obtain server response
    if  request.method=="POST":
        try:
            verify = client.verify_verify(code_form.verify_id.data, code_form.token.data)
            #on success, log response to console and render a (new) success page.
            return render_template('success.html')
        #on failure, log error to console and flash error description on same page.
        except messagebird.client.ErrorException as e:
            for error in e.errors:
                flash('  description : %s\n' % error.description)
            return redirect(url_for('enterCode', code_form=code_form, verify_id=verify_id))

    return render_template('entercode.html', code_form=code_form, verify_id=verify_id)
````

Before we move on, let's quickly dive into what happens here.

First, we instantiate the `EnterCode` class, which defines the form's fields. We want to submit the verification code together with the ID returned from the first `verify_create` request, so we store the ID in a hidden field on the form. The ID is also an argument in the route. After the user enters the verification code and clicks the submit button, the ID and the code are sent to the server using `verify_verify`. If the submission succeeds, we show the user a page with a simple success message, as defined in `success.html`:

````html
<html>
  <head>
    <title></title>
  </head>
  <body>
    <p>You have successfully verified your phone number.</p>
  </body>
</html>
````

The route for the success page is defined simply in `app.py`:

````python
def success():
    return render_template('success.html')
````

If we fail to POST the verification code successfully, error messages will be displayed above the form.


## Testing

You can add a few more lines of code in your `app.py` in order to quickly test the application:

````python
if __name__ == '__main__':
    app.run()
````

Now, let's take a quick look at the directory structure you created. It should look something like this:

````
templates
- index.html
- entercode.html
app.py
forms.py
config_file.cfg
````

If you're all set, save all your files and run the application from the command line:

````
python app.py
````

Point your browser to [http://localhost:5000/](http://localhost:5000/) and try to verify your own phone number.

## Nice work!

You now have a running integration of MessageBird's Verify API!

You can now leverage the flow, code snippets and UI examples from this tutorial to build your own two factor authentication system. Don't forget to download the code from the [MessageBird Developer Guides GitHub repository](https://github.com/messagebirdguides/verify-guide-python).


## Next steps

Want to build something similar but not quite sure how to get started? Please feel free to let us know at support@messagebird.com, we'd love to help!